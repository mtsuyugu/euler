(use srfi-1)
(use gauche.collection)

(define (value->num v)
  (cond ((and (char>=? v #\2) (char<=? v #\9)) (- (char->integer v) (char->integer #\0)))
        ((char=? v #\T) 10)
        ((char=? v #\J) 11)
        ((char=? v #\Q) 12)
        ((char=? v #\K) 13)
        ((char=? v #\A) 14)))

(define (sort-cards cards)
  (sort cards (lambda (x y) (> (number x) (number y)))))

(define (parse str)
  (fold (lambda (x y) (acons (value->num (string-ref x 0))
                             (string-ref x 1)
                             y))
        '() 
        (string-split str #\space)))

(define suit cdr)
(define number car)
(define (same-suit? c1 c2) (= (suit c1) (suit c2)))
(define (same-number? c1 c2) (= (number c1) (number c2)))
(define (same? c1 c2) (and (same-suit? c1 c2) (same-number? c1 c2)))

(define (highest sorted-cards)
  (number (car sorted-cards)))

(define (gen-n-of-a-kind2 n)
  (lambda (cards)
    (let loop ((c cards))
      (cond ((= (length c) (- n 1)) '())
            ((apply = (map (lambda (x) (number (list-ref c x))) (iota n))) c)
            (else (loop (cdr c)))))))
(define (gen-n-of-a-kind n)
  (lambda (cards)
    (let loop ((c cards))
      (cond ((= (length c) (- n 1)) '())
            ((apply = (map (lambda (x) (number (list-ref c x))) (iota n))) c)
            (else (loop (cdr c)))))))

(define one-pair (gen-n-of-a-kind 2))
(define three-of-a-kind (gen-n-of-a-kind 3))
(define four-of-a-kind (gen-n-of-a-kind 4))
(define (two-pair cards)
  (let* ((c1 (one-pair cards))
         (c2 (one-pair (cddr cards))))
    (if (null? c2) '() c1)))

(define (straight cards)
  (let loop ((c cards))
    (if (= (length c) 4)
      '()
      (let1 found (filter-map (lambda (x) (assq x c))
                              (iota 5 (highest c) -1))
            (if (= (length found) 5)
              found
              (loop (cdr c)))))))

(define (flush cards)
  (filter-map (lambda (x) 
                (if (>= (length x) 5) x #f))
              (map (lambda (s) 
                     (filter (lambda (c)
                               (char=? (suit c) s)) cards))
                   (list #\C #\S #\D #\H))))

(define (fullhouse cards)
  

(define (straight-flush cards)
  (find-max (filter-map (lambda (x) 
                (let1 found (straight x)
                      (if (null? found) 
                        #f
                        found)))
              (flush cards))
            :key highest))

(define (royal-straight-flush cards)
  (let1 found (straight-flush cards)
        (if (and (not (null? found)) (= (highest found) 14))
          found
          '())))


;(define cards (sort-cards (parse "8C TS KC 9H 4S 7D 2S 5D 3S AC")))
;(define cards (sort-cards (parse "8C 8C KC 9C 3S 5D 2S 4D 3S AC")))
; this is straight flush but straight-flush definded above can't detect
(define cards (sort-cards (parse "TC QC KC JC AC 5H 8H 7H 6H 4H")))
;(print cards)
(print (one-pair cards))
(print (two-pair cards))
(print (flush cards))
(print (straight cards))
(print (straight-flush cards))
(print (royal-straight-flush cards))
(print (three-of-a-kind cards))
