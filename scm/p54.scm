(use srfi-1)
(use gauche.collection)

(define (value->num v)
  (cond ((and (char>=? v #\2) (char<=? v #\9)) (- (char->integer v) (char->integer #\0)))
        ((char=? v #\T) 10)
        ((char=? v #\J) 11)
        ((char=? v #\Q) 12)
        ((char=? v #\K) 13)
        ((char=? v #\A) 14)))

(define (sort-cards cards)
  (sort cards (lambda (x y)
                (if (= (number x) (number y))
                  (char>? (suit x) (suit y))
                  (> (number x) (number y))))))

(define (parse str)
  (fold (lambda (x y) (acons (value->num (string-ref x 0))
                             (string-ref x 1)
                             y))
        '() 
        (string-split str #\space)))

(define suit cdr)
(define number car)
(define (same-suit? c1 c2) (char=? (suit c1) (suit c2)))
(define (same-number? c1 c2) (= (number c1) (number c2)))
(define (same? c1 c2) (and (same-suit? c1 c2) (same-number? c1 c2)))

(define (highest sorted-cards)
  (number (car sorted-cards)))

(define (gen-n-of-a-kind2 n)
  (lambda (cards)
    (let loop ((c cards))
      (cond ((= (length c) (- n 1)) '())
            ((apply = (map (lambda (x) (number (list-ref c x))) (iota n))) c)
            (else (loop (cdr c)))))))
(define (gen-n-of-a-kind n)
  (lambda (cards)
    (let loop ((c cards))
      (cond ((= (length c) (- n 1)) '())
            ((apply = (map (lambda (x) (number (list-ref c x))) (iota n))) (take c n))
            (else (loop (cdr c)))))))

(define (high-card cards) (list (car cards)))
(define one-pair (gen-n-of-a-kind 2))
(define three-of-a-kind (gen-n-of-a-kind 3))
(define four-of-a-kind (gen-n-of-a-kind 4))
(define (two-pair cards)
  (let loop ((c cards))
    (cond ((= (length c) 3) '())
          ((apply = (map (lambda (x) (number (list-ref c x))) (iota 2))) 
           (let ((first-pair (take c 2))
                 (second-pair (one-pair (drop c 2))))
             (if (null? second-pair) '()
               (append first-pair second-pair))))
          (else (loop (cdr c))))))

(define (straight cards)
  (let ((num-of-first (number (first cards))))
    (if (every (lambda (n) (= num-of-first (+ n (number (list-ref cards n))))) (iota 4 1))
    cards '())))

(define (flush cards)
  (let ((found (any (lambda (x) 
                       (if (>= (length x) 5) x #f))
                     (map (lambda (s) 
                            (filter (lambda (c)
                                      (char=? (suit c) s)) cards))
                          (list #\C #\S #\D #\H)))))
    (if found found '())))

(define (fullhouse cards)
  (let ((three-cards (three-of-a-kind cards)))
    (if (null? three-cards) '()
      (cond ((and (every same? (take cards 2) (take three-cards 2))
                  (= (number (fourth cards)) (number (fifth cards))))
             cards)
            ((and (every same? (drop cards 3) (drop three-cards 1))
                  (= (number (first cards)) (number (second cards))))
             (append three-cards (list (first cards) (second cards))))
            (else '())))))

(define (straight-flush cards)
  (if (and (pair? (straight cards))
           (pair? (flush cards)))
    cards
    '()))

(define (royal-straight-flush cards)
  (if (and (pair? (straight-flush cards))
           (= (number (car cards)) 14))
    cards
    '()))

(define (find-hands cards)
  (define point car)
  (define rank cdr)
  (any (lambda (rank-and-point)
         (let ((ranked-cards ((rank rank-and-point) cards)))
           (if (pair? ranked-cards)
             (cons (point rank-and-point) ranked-cards)
             #f)))
       (list (cons 9 royal-straight-flush)
             (cons 8 straight-flush)
             (cons 7 four-of-a-kind)
             (cons 6 fullhouse)
             (cons 5 flush)
             (cons 4 straight)
             (cons 3 three-of-a-kind)
             (cons 2 two-pair)
             (cons 1 one-pair)
             (cons 0 high-card))))

(define (compare-same-rank hands1 hands2)
  (any (lambda (card1 card2)
         (let ((num1 (number card1))
               (num2 (number card2))) 
           (cond ((= num1 num2) #f)
                 ((< num1 num2) 0)
                 (else 1))))
       hands1 hands2))

(define (versus cards1 cards2)
  (let* ((hands1 (find-hands cards1))
         (hands2 (find-hands cards2)) 
         (point1 (car hands1))
         (point2 (car hands2)))
    (cond ((> point1 point2) 1)
          ((< point1 point2) 0)
          (else
            (let ((result-comp (compare-same-rank (cdr hands1) (cdr hands2))))
              (if result-comp result-comp
                (let ((result-comp-every (compare-same-rank cards1 cards2)))
                  (if result-comp-every result-comp-every 
                    0))))))))

(define p54 (lambda () 
  (call-with-input-file "p54.dat"
    (lambda (port)
      (letrec ((iter (lambda (line n)
                       (if (eof-object? line)
                         n
                         (let* ((player1-card (sort-cards (parse (substring line 0 14))))
                                (player2-card (sort-cards (parse (substring line 15 29))))
                                (result (versus player1-card player2-card)))
                           (iter (read-line port) (+ n result)))))))
        (iter (read-line port) 0))))))

                           
(print (p54))

