(define p89 (lambda ()  
  (call-with-input-file "p89.dat" (lambda (port)
    (letrec ((iter (lambda (line len1 len2)
                     (if (eof-object? line)
                       (- len1 len2)
                       (begin
                         (iter (read-line port)
                               (+ len1 (string-length line))
                               (+ len2 (string-length (format-roman (parse-roman line)))))
                               )))))
      (iter (read-line port) 0 0))))))


(define-syntax gen
  (syntax-rules (else)
   ((_ base unit unit5 unit10 next-str next-iter)
    (lambda (num str)
      (let* ((n (quotient num base))
             (next-n (- num (* n base))))
        (next-iter next-n (cond ((>= num (* 9 base)) (string-append str (string unit unit10))) 
                                ((>= num (* 5 base)) (next-str str (string unit5) unit (quotient (- num (* 5 base)) base)))
                                ((>= num (* 4 base)) (string-append str (string unit unit5)))
                                (else (next-str str unit n)))))))))

(define (format-roman num)
  (letrec ((next-str (lambda (str b . c)
                       (if (> (length c) 1)
                         (string-append str b (make-string (cadr c) (car c)))
                         (string-append str (make-string (car c) b)))))
           (iter (lambda (num str) 
                   (let* ((n (quotient num 1000))
                          (next-n (- num (* n 1000))))
                     (iter2 next-n (if (>= num 1000) 
                                     (next-str str #\M n)
                                     str)))))
           (iter2 (gen 100 #\C #\D #\M next-str iter3))
           (iter3 (gen 10 #\X #\L #\C next-str iter4))
           (iter4 (lambda (num str) 
                    (string-append str (cond ((>= num 9) "IX")
                                             ((>= num 5) (next-str "V" #\I (- num 5)))
                                             ((>= num 4) "IV") 
                                             (else (make-string num #\I)))))))
    (iter num "")))


(define (parse-roman str)
  (define (next-num num x y a b)
                    (+ num (- (* x (string-length b)) (* y (string-length a)))))
  (define (iter str num)
    (rxmatch-cond (test (= (string-length str) 0) num)
                  ((rxmatch #/^(C*)(M+)(.*)/ str)
                   (#f a b rest)
                   (iter rest (next-num num 1000 100 a b)))
                  ((rxmatch #/^(C*)(D+)(.*)/ str)
                   (#f a b rest)
                   (iter rest (next-num num 500 100 a b)))
                  ((rxmatch #/^(X*)(C+)(.*)/ str)
                   (#f a b rest)
                   (iter rest (next-num num 100 10 a b)))
                  ((rxmatch #/^(X*)(L+)(.*)/ str)
                   (#f a b rest)
                   (iter rest (next-num num 50 10 a b)))
                  ((rxmatch #/^(I*)(X+)(.*)/ str)
                   (#f a b rest)
                   (iter rest (next-num num 10 1 a b))) 
                  ((rxmatch #/^(I*)(V+)(.*)/ str)
                   (#f a b rest)
                   (iter rest (next-num num 5 1 a b)))
                  ((rxmatch #/^(I+)(.*)/ str)
                   (#f a rest)
                   (iter rest (+ num (string-length a))))
                  (else
                    (format #t "invalid: ~s" num)
                    #f)))
  (iter str 0))

(print (p89))

